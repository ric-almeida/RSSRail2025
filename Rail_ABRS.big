# Segments and Segment Links
ctrl Segment = 0;    # Tracks are represented by Segments and nest the following entities:
# Start and End Links
atomic ctrl SLinkS = 2;   
atomic ctrl SLinkE = 2;
atomic fun ctrl SegName(s) = 0;
ctrl E = 0;     # Is this track electrified?
atomic ctrl Yes = 0; # Yes
atomic ctrl No = 0;  # No
atomic ctrl RStops = 1;  # If there's a Route that stops at this track (eg, a station), then RStops will link to the Stops of that Route

int max_trains = 5;
atomic fun ctrl Train_name(rnum) = 0;          # Name of the train
atomic fun ctrl Train_route(rroute) = 0;          # Name of the train
ctrl Num_taken = 0;
atomic fun ctrl Num(route,num) = 0;

ctrl Routes = 0;
fun ctrl R(name) = 0;         # Routes are distinguished by their name (eg, A, B, C, etc), and nest the following entities:
atomic ctrl Start = 1;        # Links to the SLinkS of this Route's starting track
atomic ctrl End = 1;          # Links to the SLinkE of its last track
atomic ctrl Trains = 1;       # Links to the current active Train(s) on this Route, if any
atomic ctrl Stops = 1;        # Links to all the tracks in this Route that are Stops (eg, stations)
atomic ctrl Consumption = 1;  # Links to its EnergyLog

ctrl Train = 0;                      # A generic train, which has:
atomic fun ctrl Charge(x) = 0;       # The current charge (in percentage)
atomic ctrl OutOfBattery = 0;        # A flag that indicates it's run out of battery
atomic fun ctrl Lowest(x) = 0;       # The Lowest charge level the current Train has seen
atomic ctrl Route = 1;               # Links to this Train's Route
atomic ctrl RouteP = 1;              # Links to the previous track in this Train's Route
atomic ctrl RouteN = 1;              # Links to the next track in this Train's Route
atomic ctrl Clock = 1;               # Links to this Train's Local Clock in the Clocks perspective/region
ctrl Action = 0;                     # The current Action of the train, which can be:
atomic ctrl Move = 0;                # Move if it's ready to move to the next track
atomic ctrl Update = 0;              # Update the current Action
ctrl Wait = 0;                       # Wait, which is created when the train reaches a stop in the Route, and which will contain:
atomic ctrl Waiting = 0;             # Waiting, if the train is still waiting at the stop
atomic fun ctrl Time(t) = 0;         # How much left it has to wait for
atomic ctrl Over = 0;                # Over if the waiting has finished

ctrl Clocks = 0;                     # Train movements are synchronized using clocks
atomic fun ctrl GC(t) = 0;           # The Global Clock keeps the Local Clocks in sync thanks to the instantaneous reactions
atomic fun ctrl LC(t) = 1;           # One Local Clock per train

ctrl EnergyLog = 0;         # Will Log, for each Route and for the present electrification configuration, a safe amount of charge at the start that ensures the Route will be completed still with 5% left
ctrl Log = 1;
atomic fun ctrl MinBatt(x) = 0;
atomic ctrl Open = 0;       # A log is opened when the first Train from the corresponding Route arrives, and closed once it leaves

# Bigraph macros
int batt_level_min = 0;     # Battery levels are given in percentage, and thus are within 0 and 100
int batt_level_max = 100;
int batt_level_incs = 10;   # Every battery increment (every charge) is of 10%
int batt_level_decs = 5;    # Every discharge is of 5%
int batt_level_min_incs_decs = batt_level_decs;   # The minimum of the two is the decrements
int time_incs = 10;         # Every clock tick increases time by 10 units (eg, 10 minutes)
int time_end = 750;         # We consider 12hrs worth of trains
int waiting_t = 10;         # Trains wait at stops for 10 minutes

# Electrify tracks T1 and T2
react electrify_T1T2 = 
    Segment.(SegName("T1") | E.1 | id) || Segment.(SegName("T2") | E.1 | id)
  -[1.0]->
    Segment.(SegName("T1") | E.Yes | id) || Segment.(SegName("T2") | E.Yes | id);

# Don't electrify tracks T1 and T2
react n_electrify_T1T2 = 
    Segment.(SegName("T1") | E.1 | id) || Segment.(SegName("T2") | E.1 | id)
  -[1.0]->
    Segment.(SegName("T1") | E.No | id) || Segment.(SegName("T2") | E.No | id);

react electrify_T6 = 
    Segment.(SegName("T6") | E.1 | id)
  -[1.0]->
    Segment.(SegName("T6") | E.Yes | id);

react n_electrify_T6 = 
    Segment.(SegName("T6") | E.1 | id)
  -[1.0]->
    Segment.(SegName("T6") | E.No | id);

react electrify_T9T10T11 = 
    Segment.(SegName("T9") | E.1 | id) || Segment.(SegName("T10") | E.1 | id) || Segment.(SegName("T11") | E.1 | id)
  -[1.0]->
    Segment.(SegName("T9") | E.Yes | id) || Segment.(SegName("T10") | E.Yes | id) || Segment.(SegName("T11") | E.Yes | id);

react n_electrify_T9T10T11 = 
    Segment.(SegName("T9") | E.1 | id) || Segment.(SegName("T10") | E.1 | id) || Segment.(SegName("T11") | E.1 | id)
  -[1.0]->
    Segment.(SegName("T9") | E.No | id) || Segment.(SegName("T10") | E.No | id) || Segment.(SegName("T11") | E.No | id);

# Open a Log with the Train's Charge at departure, and nest its Lowest charge
fun react log_charge_departure(c,route) =
       Segment.(Train.(Charge(c) | RouteP{b} | id) | id)
    || R(route).(Start{b} | Consumption{cons} | id)
    || Log{cons}.1
  -[1.0]->
       Segment.(Train.(Charge(c) | RouteP{b} | id) | id)
    || R(route).(Start{b} | Consumption{cons} | id)
    || Log{cons}.(MinBatt(c) | Open);

# Gain the Charge from traversing the current electrified track
fun react gain_charge(c,t) = 
       Segment.(Train.(Charge(c) | Clock{clock} | Action.id | id) | E.Yes | id)
    || Clocks.(LC(t-10){clock} | GC(t) | id)
  -[1.0]->
       Segment.(Train.(Charge(c+10) | Clock{clock} | Action.(id | Update) | id) | E.Yes | id)
    || Clocks.(LC(t){clock} | GC(t) | id);

# Lose the Charge from traversing the current non-electrified track
fun react lose_charge(c,t) = 
       Segment.(Train.(Charge(c) | Clock{clock} | Action.id | id) | E.No | id)
    || Clocks.(LC(t-10){clock} | GC(t) | id)
  -[1.0]->
       Segment.(Train.(Charge(c-5) | Clock{clock} | Action.(id | Update) | id) | E.No | id)
    || Clocks.(LC(t){clock} | GC(t) | id)
  if !Waiting in param;

# If stopped at a non-electrified track, the train's charge is preserved
fun react keep_charge(t) = 
       Segment.(Train.(Clock{clock} | Action.id | id) | E.No | id)
    || Clocks.(LC(t-10){clock} | GC(t) | id)
  -[1.0]->
       Segment.(Train.(Clock{clock} | Action.(id | Update) | id) | E.No | id)
    || Clocks.(LC(t){clock} | GC(t) | id)
  if Waiting in param;

# Wait at a stop for 1 time unit
fun react action_wait(t) =
  Action.(Wait.(Time(t) | Waiting) | Update) -[1.0]-> Action.(Wait.(Time(t-time_incs) | Waiting));

react action_wait_over =
  Action.(Wait.(Time(0) | Waiting)) -[1.0]-> Action.(Wait.Over);

# After the wait is over, the Train is ready to Move
react action_resume_move = 
  Action.(Wait.Over | Update) -[1.0]-> Action.(Wait.Over | Move);

react action_keep_moving = 
  Action.Update -[1.0]-> Action.Move;

# Being on an electrified track with 100% Charge keeps it at 100%
react adjust_battery_hi_1 = Charge(110) -[1.0]-> Charge(100);
react adjust_battery_hi_2 = Charge(105) -[1.0]-> Charge(100);

# If the Charge falls below the Lowest charge so far, that becomes the new Lowest
fun react update_lowest_charge(c) = 
    Train.(Charge(c-5) | Lowest(c) | id)
  -[1.0]->
    Train.(Charge(c-5) | Lowest(c-5) | id);

# If the discharge for the movement ahead depletes the Charge, the Train dies there
react adjust_battery_lo = 
    Train.(Charge(0) | Lowest(0) | Action.id | id)
  -[1.0]-> 
    Train.(OutOfBattery | id)
  @[1];

# When the Train is on the last track of its Route and ready to Move (ie, its Charge has already been updated for that track), 
# the safe battery level to complete the Route can already be computed and its EnergyLog closed
fun react log_charge_end(c_initial,c,route) =
       /b (Segment.(SLinkE{x,b} | Train.(Lowest(c) | Action.(Move | id) | RouteP{b} | RouteN{rE} | id) | id)
    || R(route).(End{rE} | Consumption{cons} | id)
    || Log{cons}.(MinBatt(c_initial) | Open) )
  -[1.0]->
       /b (Segment.(SLinkE{x,b} | Train.(Lowest(c) | Action.(Move | id) | RouteP{b} | RouteN{rE} | id) | id)
    || R(route).(End{rE} | Consumption{cons} | id)
    || Log{cons}.MinBatt(c_initial-c+batt_level_decs) );

# A Train arrives on its Route's starting track and will move to the next track on the next time unit
fun react train_starts(route,time,charge,num) = 
       Segment.(SLinkS{rS,x} | id)
    || R(route).(Start{rS} | Trains{r} | id)
    || Clocks.(GC(time) | id)
    || Num_taken.id
  -[1.0]->
      /clock (
       /a Segment.(Train.(Action.1 | Charge(charge) | Lowest(charge) | Route{r} | RouteP{rS} | RouteN{a} | Clock{clock} | Train_name(num) | Train_route(route)) | SLinkS{a,x} | id)
    || R(route).(Start{rS} | Trains{r} | id)
    || Clocks.(GC(time) | LC(time){clock} | id) )
    || Num_taken.(Num(route,num) | id)
if !Num(route,num) in param;
  
# Move Train from the first track to the second one, and reset its Action
fun react depart_train(route) =  
       Segment.(Train.(Action.(Move | id) | RouteP{b} | RouteN{a} | id) | SLinkS{a,x} | id)
    || Segment.(SLinkE{x,y} | SLinkS{y,z} | id)
    || R(route).(Start{b} | id)
  -[1.0]->
       Segment.(SLinkS{x,y} | id)  
    || Segment.(SLinkE{y,b} | Train.(Action.1 | RouteP{b} | RouteN{a} | id) | SLinkS{a,z} | id)
    || R(route).(Start{x} | id)
  @[2,1,3,4];

# Move Train between the second and penultimate tracks iteratively
react move_train =   
       Segment.(SLinkE{w,b} | Train.(Action.(Move | id) | RouteP{b} | RouteN{a} | id) | SLinkS{a,x} | id)
    || Segment.(SLinkE{x,y} | SLinkS{y,z} | id)
  -[1.0]->
       Segment.(SLinkE{w,y} | SLinkS{y,x} | id)
    || Segment.(SLinkE{x,b} | Train.(Action.1 | RouteP{b} | RouteN{a} | id) | SLinkS{a,z} | id)
  @[2,1,3];

# Move Train to the last track on its Route
fun react move_train_last_track(route) =
      /a Segment.(SLinkE{w,b} | Train.(Action.(Move | id) | RouteP{b} | RouteN{a} | id) | SLinkS{a,x} | id)
    || Segment.(SLinkE{x,rE} | id)
    || R(route).(End{rE} | id)
  -[1.0]->
      /y Segment.(SLinkE{w,y} | SLinkS{y,x} | id)
    || Segment.(SLinkE{x,b} | Train.(Action.1 | RouteP{b} | RouteN{rE} | id) | id)
    || R(route).(End{rE} | id)
  @[2,1,3,4];

# If the Train has moved to a track that is a stop for the current Route, start a waiting timer
fun react stop_on_track(route) = 
    Segment.(Train.(Action.1 | Route{r} | id) | RStops{s} | id) || R(route).(Trains{r} | Stops{s} | id)
  -[1.0]->
    Segment.(Train.(Action.Wait.(Waiting | Time(waiting_t)) | Route{r} | id) | RStops{s} | id) || R(route).(Trains{r} | Stops{s} | id);

# Train moves from the last track and leaves
fun react train_ends(t,route) =  
      /b /clock 
       ((Segment.(SLinkE{x,b} | Train.(Action.(Move | id) | RouteP{b} | RouteN{rE} | Clock{clock} | id) | id)
    || R(route).(End{rE} | id))
    || Clocks.(LC(t){clock} | id))
  -[1.0]->
       Segment.(SLinkE{x,rE} | id)
    || R(route).(End{rE} | id)
    || Clocks.id
  @[2,3,4];

# Start the Global Clock
fun react start_clock(tick_incs) = Clocks.(GC(0) | id) -[1.0]-> Clocks.(GC(tick_incs) | id);

# Increment the Global Clock by 1 time unit
fun react tick(t) = GC(t) -[1.0]-> GC(t+10);

big s0 = /rAS /rA1o /rA2i /rA2o /rA3i /rA3o /rA4i /rA4o /rAE  
         /rBS /rB1o /rB2i /rB2o /rB6i /rB6o /rBE
         /rCS /rC1o /rC8i /rC8o /rC9i /rC9o /rC10i /rC10o /rCE
         /rAC /rBC /rCC /rAtrains /rBtrains /rCtrains /rAStops /rBStops /rCStops
  (    
    ( Segment.(SegName("T1") | SLinkS{rAS,rA1o}  | SLinkS{rBS,rB1o} | SLinkS{rCS,rC1o} | E.1 )   
    | Segment.(SegName("T2") | SLinkE{rA1o,rA2i} | SLinkE{rB1o,rB2i} | SLinkS{rA2i,rA2o} | SLinkS{rB2i,rB2o} | E.1 )
    | Segment.(SegName("T3") | SLinkE{rA2o,rA3i} | SLinkS{rA3i,rA3o} | E.No)   
    | Segment.(SegName("T4") | SLinkE{rA3o,rA4i} | SLinkS{rA4i,rA4o} | E.No | RStops{rAStops})   
    | Segment.(SegName("T5") | SLinkE{rA4o,rAE}  | E.No | RStops{rAStops})   
    | Segment.(SegName("T6") | SLinkE{rB2o,rB6i} | SLinkS{rB6i,rB6o} | E.1)   
    | Segment.(SegName("T7") | SLinkE{rB6o,rBE}  | E.No | RStops{rBStops})   
    | Segment.(SegName("T8") | SLinkE{rC1o,rC8i} | SLinkS{rC8i,rC8o} | E.No) 
    | Segment.(SegName("T9") | SLinkE{rC8o,rC9i} | SLinkS{rC9i,rC9o} | E.1 | RStops{rCStops})   
    | Segment.(SegName("T10") | SLinkE{rC9o,rC10i} | SLinkS{rC10i,rC10o} | E.1 | RStops{rCStops})   
    | Segment.(SegName("T11") | SLinkE{rC10o,rCE} | E.1 | RStops{rCStops})   
    )
  || 
    Routes.(R("A").(Start{rAS} | End{rAE} | Trains{rAtrains} | Consumption{rAC} | Stops{rAStops}) 
          | R("B").(Start{rBS} | End{rBE} | Trains{rBtrains} | Consumption{rBC} | Stops{rBStops}) 
          | R("C").(Start{rCS} | End{rCE} | Trains{rCtrains} | Consumption{rCC} | Stops{rCStops}))
  ||
    EnergyLog.(Log{rAC}.1 | Log{rBC}.1 | Log{rCC}.1) 
  ||
    Clocks.(GC(0))
  ||
    Num_taken.1
  );

# Sanity predicates
# Error if Charge/MinBatt < 0 or > 100
fun big er_charge_below_min(x) = Charge(x);
fun big er_lowest_below_min(x) = Lowest(x);
fun big er_min_batt_below_min(x) = MinBatt(x);
fun big er_charge_above_min(x) = Charge(x);
fun big er_lowest_above_min(x) = Lowest(x);
fun big er_min_batt_above_min(x) = MinBatt(x);
# Error if Charge < Lowest
fun big er_charge_lt_lowest(x,dec) = Train.(Charge(batt_levels-dec) | Lowest(batt_levels) | id); 
big er_move_visible = Move;
big er_SLinkS_unlinked = /x SLinkS{x,y};
big er_double_updates = Action.(Update | Update | id);

# No 2 Trains on the same track at the same time
big er_danger = Segment.(Train.id | Train.id | id);

# Debugging predicates
fun big live(track,curr_ch,lowest_ch) = Segment.(SegName(track) | Train.(Charge(curr_ch) | Lowest(lowest_ch) | id) | id );
fun big waiting(route,track) = Segment.(SegName(track) | Train.(Action.(Wait.id | id) | Route{r} | id) | id) || R(route).(Trains{r} | id); 

# Predicates for Analysis and Queries
fun big oob_at(track,t) = 
     Segment.(SegName(track) | Train.(OutOfBattery | Clock{clock} | id) | id)
  || Clocks.(LC(t){clock} | id);

big oob = OutOfBattery;

begin abrs
  string routes = {"A", "B", "C"};
  string tracks = {"T1", "T2", "T3", "T4", "T5", "T6", "T7", "T8", "T9", "T10", "T11"};
  int batt_levels = [batt_level_min:batt_level_min_incs_decs:batt_level_max];
  int batt_levels2 = [batt_level_min:batt_level_min_incs_decs:batt_level_max];
  int er_charge_below_mins = {-5};
  int er_charge_above_mins = {105, 110};
  int times = [time_incs:time_incs:time_end];
  int waiting_times = [time_incs:time_incs:waiting_t];
  int route_A_timetable = [20:80:(time_end-50)];  # At min 20 and then every 80min, for 12 hors
  int route_B_timetable = [10:20:(time_end-50)];  # At min 10 and then every 20min
  int route_C_timetable = [40:40:(time_end-50)];  # Every 40min
  int num = [1:1:max_trains];
  init s0;
  rules = [
    ( log_charge_departure(batt_levels,routes) ),
    ( gain_charge(batt_levels,times), lose_charge(batt_levels,times), keep_charge(times) ),
    ( action_wait(waiting_times), action_wait_over, action_resume_move, action_keep_moving ),
    ( adjust_battery_hi_1, adjust_battery_hi_2 ),
    ( update_lowest_charge(batt_levels) ),
    ( adjust_battery_lo ),  
    ( log_charge_end(batt_levels,batt_levels2,routes) ),
    ( depart_train(routes), move_train, move_train_last_track(routes) ),
    ( stop_on_track(routes) ),
    ( train_ends(times,routes) ),
    ( train_starts("A",route_A_timetable,100,num), train_starts("B",route_B_timetable,100,num), train_starts("C",route_C_timetable,100,num) ),
    { electrify_T1T2, n_electrify_T1T2 }, 
    { electrify_T6, n_electrify_T6 }, 
    { electrify_T9T10T11, n_electrify_T9T10T11 },
    { start_clock(time_incs) },
    { tick(times) }    
    ];
  actions = [
    electrify_T1T2 = { electrify_T1T2 },
    dont_electrify_T1T2 = { n_electrify_T1T2 },
    electrify_T6 = { electrify_T6 }, 
    dont_electrify_T6 = { n_electrify_T6 }, 
    electrify_T9T10T11 = { electrify_T9T10T11 }, 
    dont_electrify_T9T10T11 = { n_electrify_T9T10T11 }, 
    start_clock = { start_clock },
    move = { log_charge_departure, gain_charge, lose_charge, keep_charge, action_wait, action_wait_over, action_resume_move, action_keep_moving, 
             adjust_battery_hi_1, adjust_battery_hi_2, update_lowest_charge, adjust_battery_lo, log_charge_end, 
             depart_train, move_train, move_train_last_track, stop_on_track, train_ends },
    tick = { tick, train_starts },
    dbg = { check_correct_electr_none, check_correct_electr_T1T2, check_correct_electr_T6, check_correct_electr_T9T10T11, check_correct_electr_T1T2T6, check_correct_electr_T6T9T10T11, check_correct_electr_T1T2T9T10T11, check_correct_electr_T1T2T6T9T10T11 }
  ];
  preds = { 
            live(tracks,batt_levels,batt_levels2), waiting(routes,tracks), oob_at(tracks,times), oob
          };
end
