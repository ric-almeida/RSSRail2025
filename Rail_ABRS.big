# Segments and Segment Links
ctrl Segment = 0;    # Tracks are represented by Segments and nest the following entities:
# Start and End Links
ctrl WP = 1;         # A waypoint linking linking to the previous segment on the current route, nesting:
atomic ctrl Next = 1;            # pointer to the next segment's WP
atomic fun ctrl SName(s) = 0;
ctrl E = 0;     # Is this track electrified?
atomic ctrl Yes = 0; # Yes
atomic ctrl No = 0;  # No
atomic ctrl RStops = 1;  # If there's a Route that stops at this track (eg, a station), then RStops will link to the Stops of that Route

int max_trains = 5;
atomic fun ctrl Train_name(rnum) = 0;          # Name of the train, for analysis purposes
atomic fun ctrl Train_route(rroute) = 0;       # Name of the train
ctrl Num_taken = 0;
atomic fun ctrl Num(route,num) = 0;

ctrl Routes = 0;
fun ctrl R(name) = 0;         # Routes are distinguished by their name (eg, A, B, C, etc), and nest the following entities:
atomic ctrl Start = 1;        # Links to the SLinkS of this Route's starting track
atomic ctrl Trains = 1;       # Links to the current active Train(s) on this Route, if any
atomic ctrl Stops = 1;        # Links to all the tracks in this Route that are Stops (eg, stations)
atomic ctrl Consumption = 1;  # Links to its EnergyLog

ctrl Train = 0;                      # A generic train, which has:
atomic fun ctrl Charge(x) = 0;       # The current charge (in percentage)
atomic ctrl OutOfBattery = 0;        # A flag that indicates it's run out of battery
atomic fun ctrl Lowest(x) = 0;       # The Lowest charge level the current Train has seen
atomic ctrl Route = 1;               # Links to this Train's Route
atomic ctrl RouteN = 1;              # Links to the next track in this Train's Route
atomic fun ctrl LC(t) = 0;           # One Local Clock per train
ctrl Action = 0;                     # The current Action of the train, which can be:
atomic ctrl Move = 0;                # Move if it's ready to move to the next track
atomic ctrl Update = 0;              # Update the current Action
ctrl Wait = 0;                       # Wait, which is created when the train reaches a stop in the Route, and which will contain:
atomic ctrl Waiting = 0;             # Waiting, if the train is still waiting at the stop
atomic fun ctrl Time(t) = 0;         # How much left it has to wait for
atomic ctrl Over = 0;                # Over if the waiting has finished

ctrl Clock = 0;                      # Train movements are synchronized using clocks
atomic fun ctrl GC(t) = 0;           # The Global Clock keeps the Local Clocks in sync thanks to the instantaneous reactions

ctrl EnergyLog = 0;         # Will Log, for each Route and for the present electrification configuration, a safe amount of charge at the start that ensures the Route will be completed still with 5% left
ctrl Log = 1;
atomic fun ctrl MinBatt(x) = 0;
atomic ctrl Open = 0;       # A log is opened when the first Train from the corresponding Route arrives, and closed once it leaves

# Bigraph macros
int batt_level_min = 0;     # Battery levels are given in percentage, and thus are within 0 and 100
int batt_level_max = 100;
int batt_level_incs = 10;   # Every battery increment (every charge) is of 10%
int batt_level_decs = 5;    # Every discharge is of 5%
int batt_level_min_incs_decs = batt_level_decs;   # The minimum of the two is the decrements
int time_incs = 10;         # Every clock tick increases time by 10 units (eg, 10 minutes)
int time_end = 750;         # We consider 12hrs worth of trains
int waiting_t = 10;         # Trains wait at stops for 10 minutes

# Electrify tracks T1 and T2
react electrify_T1T2 = 
    Segment.(SName("T1") | E.1 | id) || Segment.(SName("T2") | E.1 | id)
  -[1.0]->
    Segment.(SName("T1") | E.Yes | id) || Segment.(SName("T2") | E.Yes | id);

# Don't electrify tracks T1 and T2
react n_electrify_T1T2 = 
    Segment.(SName("T1") | E.1 | id) || Segment.(SName("T2") | E.1 | id)
  -[1.0]->
    Segment.(SName("T1") | E.No | id) || Segment.(SName("T2") | E.No | id);

react electrify_T6 = 
    Segment.(SName("T6") | E.1 | id)
  -[1.0]->
    Segment.(SName("T6") | E.Yes | id);

react n_electrify_T6 = 
    Segment.(SName("T6") | E.1 | id)
  -[1.0]->
    Segment.(SName("T6") | E.No | id);

react electrify_T9T10T11 = 
    Segment.(SName("T9") | E.1 | id) || Segment.(SName("T10") | E.1 | id) || Segment.(SName("T11") | E.1 | id)
  -[1.0]->
    Segment.(SName("T9") | E.Yes | id) || Segment.(SName("T10") | E.Yes | id) || Segment.(SName("T11") | E.Yes | id);

react n_electrify_T9T10T11 = 
    Segment.(SName("T9") | E.1 | id) || Segment.(SName("T10") | E.1 | id) || Segment.(SName("T11") | E.1 | id)
  -[1.0]->
    Segment.(SName("T9") | E.No | id) || Segment.(SName("T10") | E.No | id) || Segment.(SName("T11") | E.No | id);

# Open a Log with the Train's Charge at departure, and nest its Lowest charge
fun react log_charge_departure(c,route) =
       Segment.(Train.(Charge(c) | RouteN{rS} | id) | id)
    || R(route).(Start{rS} | Consumption{cons} | id)
    || Log{cons}.1
  -[1.0]->
       Segment.(Train.(Charge(c) | RouteN{rS} | id) | id)
    || R(route).(Start{rS} | Consumption{cons} | id)
    || Log{cons}.(MinBatt(c) | Open);

# Gain the Charge from traversing the current electrified track
fun react gain_charge(c,t) = 
       Segment.(Train.(Charge(c) | LC(t-10) | Action.id | id) | E.Yes | id)
    || Clock.(GC(t))
  -[1.0]->
       Segment.(Train.(Charge(c+10) | LC(t) | Action.(id | Update) | id) | E.Yes | id)
    || Clock.(GC(t));

# Lose the Charge from traversing the current non-electrified track
fun react lose_charge(c,t) = 
       Segment.(Train.(Charge(c) | LC(t-10) | Action.id | id) | E.No | id)
    || Clock.(GC(t))
  -[1.0]->
       Segment.(Train.(Charge(c-5) | LC(t) | Action.(id | Update) | id) | E.No | id)
    || Clock.(GC(t))
  if !Waiting in param;

# If stopped at a non-electrified track, the train's charge is preserved
fun react keep_charge(t) = 
       Segment.(Train.(LC(t-10) | Action.id | id) | E.No | id)
    || Clock.(GC(t))
  -[1.0]->
       Segment.(Train.(LC(t) | Action.(id | Update) | id) | E.No | id)
    || Clock.(GC(t))
  if Waiting in param;

# Wait at a stop for 1 time unit
fun react action_wait(t) =
  Action.(Wait.(Time(t) | Waiting) | Update) -[1.0]-> Action.(Wait.(Time(t-time_incs) | Waiting));

react action_wait_over =
  Action.(Wait.(Time(0) | Waiting)) -[1.0]-> Action.(Wait.Over);

# After the wait is over, the Train is ready to Move
react action_resume_move = 
  Action.(Wait.Over | Update) -[1.0]-> Action.(Wait.Over | Move);

react action_keep_moving = 
  Action.Update -[1.0]-> Action.Move;

# Being on an electrified track with 100% Charge keeps it at 100%
react adjust_battery_hi_1 = Charge(110) -[1.0]-> Charge(100);
react adjust_battery_hi_2 = Charge(105) -[1.0]-> Charge(100);

# If the Charge falls below the Lowest charge so far, that becomes the new Lowest
fun react update_lowest_charge(c) = 
    Train.(Charge(c-5) | Lowest(c) | id)
  -[1.0]->
    Train.(Charge(c-5) | Lowest(c-5) | id);

# If the discharge for the movement ahead depletes the Charge, the Train dies there
react adjust_battery_lo = 
    Train.(Charge(0) | Lowest(0) | Action.id | id)
  -[1.0]-> 
    Train.(OutOfBattery | id)
  @[1];

# When the Train is on the last track of its Route and ready to Move (ie, its Charge has already been updated for that track), 
# the safe battery level to complete the Route can already be computed and its EnergyLog closed
fun react log_charge_end(c_initial,c,route) =
       (Segment.(WP{x}.1 | Train.(Lowest(c) | Action.(Move | id) | Route{r} | id) | id)
    || R(route).(Trains{r} | Consumption{cons} | id)
    || Log{cons}.(MinBatt(c_initial) | Open) )
  -[1.0]->
       (Segment.(WP{x}.1 | Train.(Lowest(c) | Action.(Move | id) | Route{r} | id) | id)
    || R(route).(Trains{r} | Consumption{cons} | id)
    || Log{cons}.MinBatt(c_initial-c+batt_level_decs) );

# A Train arrives on its Route's starting track and will move to the next track on the next time unit
fun react train_starts(route,time,charge,num) = 
       Segment.(WP{rS}.id | id)
    || /r R(route).(Start{rS} | Trains{r} | id)
    || Clock.(GC(time))
    || Num_taken.id
  -[1.0]->
       /r (
       Segment.(WP{rS}.id | Train.(Action.1 | Charge(charge) | Route{r} | RouteN{rS} | LC(time)) | id)
    || R(route).(Start{rS} | Trains{r} | id)
    || Clock.(GC(time)))
    || Num_taken.(Num(route,num) | id)
if !Num(route,num) in param;

# Move Train between the second and penultimate tracks iteratively
react move_train =   
       Segment.(WP{r}.Next{n} | Train.(Action.(Move | id) | RouteN{r} | id) | id)
    || Segment.(WP{n}.id | id)
  -[1.0]->
       Segment.(WP{r}.Next{n} | id)
    || Segment.(WP{n}.id | Train.(Action.1 | RouteN{n} | id) | id)
  @[2,3,1,4];

# If the Train has moved to a track that is a stop for the current Route, start a waiting timer
fun react stop_on_track(route) = 
    Segment.(Train.(Action.1 | Route{r} | id) | RStops{s} | id) || R(route).(Trains{r} | Stops{s} | id)
  -[1.0]->
    Segment.(Train.(Action.Wait.(Waiting | Time(waiting_t)) | Route{r} | id) | RStops{s} | id) || R(route).(Trains{r} | Stops{s} | id);

# Train moves from the last track and leaves
fun react train_ends(t,route) =  
    Segment.(WP{r}.1 | Train.(Action.(Move | id) | RouteN{r} | LC(t) | id) | id)
  -[1.0]->
    Segment.(WP{r}.1 | id)
  @[2];

# Start the Global Clock
fun react start_clock(tick_incs) = Clock.(GC(0)) -[1.0]-> Clock.(GC(tick_incs));

# Increment the Global Clock by 1 time unit
fun react tick(t) = GC(t) -[1.0]-> GC(t+10);

big s0 = /rAS /rA2 /rA3 /rA4 /rA5  
         /rBS /rB2 /rB6 /rB7 
         /rCS /rC8 /rC9 /rC10 /rC11
         /rAC /rBC /rCC /rAtrains /rBtrains /rCtrains /rAStops /rBStops /rCStops
  (    
    ( Segment.(SName("T1") | WP{rAS}.Next{rA2}  | WP{rBS}.Next{rB2} | WP{rCS}.Next{rC8} | E.1 )   
    | Segment.(SName("T2") | WP{rA2}.Next{rA3} | WP{rB2}.Next{rB6} | E.1 )
    | Segment.(SName("T3") | WP{rA3}.Next{rA4} | E.No)   
    | Segment.(SName("T4") | WP{rA4}.Next{rA5} | E.No | RStops{rAStops})   
    | Segment.(SName("T5") | WP{rA5}.1  | E.No | RStops{rAStops})   
    | Segment.(SName("T6") | WP{rB6}.Next{rB7} | E.1)   
    | Segment.(SName("T7") | WP{rB7}.1 | E.No | RStops{rBStops})   
    | Segment.(SName("T8") | WP{rC8}.Next{rC9} | E.No) 
    | Segment.(SName("T9") | WP{rC9}.Next{rC10}  | E.1 | RStops{rCStops})   
    | Segment.(SName("T10") | WP{rC10}.Next{rC11} | E.1 | RStops{rCStops})   
    | Segment.(SName("T11") | WP{rC11}.1 | E.1 | RStops{rCStops})   
    )
  || 
    Routes.(R("A").(Start{rAS} | Trains{rAtrains} | Consumption{rAC} | Stops{rAStops}) 
          | R("B").(Start{rBS} | Trains{rBtrains} | Consumption{rBC} | Stops{rBStops}) 
          | R("C").(Start{rCS} | Trains{rCtrains} | Consumption{rCC} | Stops{rCStops}))
  ||
    EnergyLog.(Log{rAC}.1 | Log{rBC}.1 | Log{rCC}.1) 
  ||
    Clock.(GC(0))
  ||
    Num_taken.1
  );

# Sanity predicates
# Error if Charge/MinBatt < 0 or > 100
fun big er_charge_below_min(x) = Charge(x);
fun big er_lowest_below_min(x) = Lowest(x);
fun big er_min_batt_below_min(x) = MinBatt(x);
fun big er_charge_above_min(x) = Charge(x);
fun big er_lowest_above_min(x) = Lowest(x);
fun big er_min_batt_above_min(x) = MinBatt(x);
# Error if Charge < Lowest
fun big er_charge_lt_lowest(x,dec) = Train.(Charge(batt_levels-dec) | Lowest(batt_levels) | id); 
big er_move_visible = Move;
big er_WP_unlinked = /x WP{x}.id;
big er_Next_unlinked = /x WP{y}.Next{x};
big er_double_updates = Action.(Update | Update | id);

# No 2 Trains on the same track at the same time
big er_danger = Segment.(Train.id | Train.id | id);

# Debugging predicates
fun big live(track,curr_ch,lowest_ch) = Segment.(SName(track) | Train.(Charge(curr_ch) | Lowest(lowest_ch) | id) | id );
fun big waiting(route,track) = Segment.(SName(track) | Train.(Action.(Wait.id | id) | Route{r} | id) | id) || R(route).(Trains{r} | id); 

# Predicates for Analysis and Queries
fun big oob_at(track,t) = 
     Segment.(SName(track) | Train.(OutOfBattery | LC(t) | id) | id)
  || Clock.(id);

big oob = OutOfBattery;

fun big tr_use1(track) = Segment.(SName(track) | Train.id | id );
fun big train_battery_tracker(ch,route,num) = Train.(Train_name(num) | Train_route(route) | Charge(ch) | id);
fun big tr_use(track,ch) = Segment.(SName(track) | Train.(Charge(ch) | id) | id );

begin abrs
  string routes = {"A", "B", "C"};
  string tracks = {"T1", "T2", "T3", "T4", "T5", "T6", "T7", "T8", "T9", "T10", "T11"};
  int batt_levels = [batt_level_min:batt_level_min_incs_decs:batt_level_max];
  int batt_levels2 = [batt_level_min:batt_level_min_incs_decs:batt_level_max];
  int er_charge_below_mins = {-5};
  int er_charge_above_mins = {105, 110};
  int times = [time_incs:time_incs:time_end];
  int waiting_times = [time_incs:time_incs:waiting_t];
  int route_A_timetable = [20:80:(time_end-50)];  # At min 20 and then every 80min, for 12 hors
  int route_B_timetable = [10:20:(time_end-50)];  # At min 10 and then every 20min
  int route_C_timetable = [40:40:(time_end-50)];  # Every 40min
  int num = [1:1:max_trains];
  init s0;
  rules = [
    ( log_charge_departure(batt_levels,routes) ),
    ( gain_charge(batt_levels,times), lose_charge(batt_levels,times), keep_charge(times) ),
    ( action_wait(waiting_times), action_wait_over, action_resume_move, action_keep_moving ),
    ( adjust_battery_hi_1, adjust_battery_hi_2 ),
    ( update_lowest_charge(batt_levels) ),
    ( adjust_battery_lo ),  
    ( log_charge_end(batt_levels,batt_levels2,routes) ),
    ( move_train ),
    ( stop_on_track(routes) ),
    ( train_ends(times,routes) ),
    ( train_starts("A",route_A_timetable,100,num), train_starts("B",route_B_timetable,100,num), train_starts("C",route_C_timetable,100,num) ),
    { electrify_T1T2, n_electrify_T1T2 }, 
    { electrify_T6, n_electrify_T6 }, 
    { electrify_T9T10T11, n_electrify_T9T10T11 },
    { start_clock(time_incs) },
    { tick(times) }    
    ];
  actions = [
    electrify_T1T2 = { electrify_T1T2 },
    dont_electrify_T1T2 = { n_electrify_T1T2 },
    electrify_T6 = { electrify_T6 }, 
    dont_electrify_T6 = { n_electrify_T6 }, 
    electrify_T9T10T11 = { electrify_T9T10T11 }, 
    dont_electrify_T9T10T11 = { n_electrify_T9T10T11 }, 
    start_clock = { start_clock },
    move = { log_charge_departure, gain_charge, lose_charge, keep_charge, action_wait, action_wait_over, action_resume_move, action_keep_moving, 
             adjust_battery_hi_1, adjust_battery_hi_2, update_lowest_charge, adjust_battery_lo, log_charge_end, 
             move_train, stop_on_track, train_ends },
    tick = { tick, train_starts },
    dbg = { check_correct_electr_none, check_correct_electr_T1T2, check_correct_electr_T6, check_correct_electr_T9T10T11, check_correct_electr_T1T2T6, check_correct_electr_T6T9T10T11, check_correct_electr_T1T2T9T10T11, check_correct_electr_T1T2T6T9T10T11 }
  ];
  preds = { 
            live(tracks,batt_levels,batt_levels2), waiting(routes,tracks), oob_at(tracks,times), oob,
            train_battery_tracker(batt_levels,routes,num),
            tr_use(tracks,batt_levels)

            # Track Usage Analysis: uncomment the line below corresponding to the track track to analyse
            #, tr_use1("T1")[1]
            #, tr_use1("T2")[1]
            #, tr_use1("T3")[1]
            #, tr_use1("T4")[1]
            #, tr_use1("T5")[1]
            #, tr_use1("T6")[1]
            #, tr_use1("T7")[1]
            , tr_use1("T8")[1]
            #, tr_use1("T9")[1]
            #, tr_use1("T10")[1]
            #, tr_use1("T11")[1]

            # Battery levels per track analysis: uncomment the line corresponding to the track to analyse 

            #, tr_use("T1", 5)[5], tr_use("T1", 10)[10], tr_use("T1", 15)[15], tr_use("T1", 20)[20], tr_use("T1", 25)[25], tr_use("T1", 30)[30], tr_use("T1", 35)[35], tr_use("T1", 40)[40], tr_use("T1", 45)[45], tr_use("T1", 50)[50], tr_use("T1", 55)[55], tr_use("T1", 60)[60], tr_use("T1", 65)[65], tr_use("T1", 70)[70], tr_use("T1", 75)[75], tr_use("T1", 80)[80], tr_use("T1", 85)[85], tr_use("T1", 90)[90], tr_use("T1", 95)[95], tr_use("T1", 100)[100] 
            
            #, tr_use("T2", 5)[5], tr_use("T2", 10)[10], tr_use("T2", 15)[15], tr_use("T2", 20)[20], tr_use("T2", 25)[25], tr_use("T2", 30)[30], tr_use("T2", 35)[35], tr_use("T2", 40)[40], tr_use("T2", 45)[45], tr_use("T2", 50)[50], tr_use("T2", 55)[55], tr_use("T2", 60)[60], tr_use("T2", 65)[65], tr_use("T2", 70)[70], tr_use("T2", 75)[75], tr_use("T2", 80)[80], tr_use("T2", 85)[85], tr_use("T2", 90)[90], tr_use("T2", 95)[95], tr_use("T2", 100)[100]
            
            #, tr_use("T3", 5)[5], tr_use("T3", 10)[10], tr_use("T3", 15)[15], tr_use("T3", 20)[20], tr_use("T3", 25)[25], tr_use("T3", 30)[30], tr_use("T3", 35)[35], tr_use("T3", 40)[40], tr_use("T3", 45)[45], tr_use("T3", 50)[50], tr_use("T3", 55)[55], tr_use("T3", 60)[60], tr_use("T3", 65)[65], tr_use("T3", 70)[70], tr_use("T3", 75)[75], tr_use("T3", 80)[80], tr_use("T3", 85)[85], tr_use("T3", 90)[90], tr_use("T3", 95)[95], tr_use("T3", 100)[100]
            
            #, tr_use("T4", 5)[5], tr_use("T4", 10)[10], tr_use("T4", 15)[15], tr_use("T4", 20)[20], tr_use("T4", 25)[25], tr_use("T4", 30)[30], tr_use("T4", 35)[35], tr_use("T4", 40)[40], tr_use("T4", 45)[45], tr_use("T4", 50)[50], tr_use("T4", 55)[55], tr_use("T4", 60)[60], tr_use("T4", 65)[65], tr_use("T4", 70)[70], tr_use("T4", 75)[75], tr_use("T4", 80)[80], tr_use("T4", 85)[85], tr_use("T4", 90)[90], tr_use("T4", 95)[95], tr_use("T4", 100)[100]
            
            #, tr_use("T5", 5)[5], tr_use("T5", 10)[10], tr_use("T5", 15)[15], tr_use("T5", 20)[20], tr_use("T5", 25)[25], tr_use("T5", 30)[30], tr_use("T5", 35)[35], tr_use("T5", 40)[40], tr_use("T5", 45)[45], tr_use("T5", 50)[50], tr_use("T5", 55)[55], tr_use("T5", 60)[60], tr_use("T5", 65)[65], tr_use("T5", 70)[70], tr_use("T5", 75)[75], tr_use("T5", 80)[80], tr_use("T5", 85)[85], tr_use("T5", 90)[90], tr_use("T5", 95)[95], tr_use("T5", 100)[100]
            
            #, tr_use("T6", 5)[5], tr_use("T6", 10)[10], tr_use("T6", 15)[15], tr_use("T6", 20)[20], tr_use("T6", 25)[25], tr_use("T6", 30)[30], tr_use("T6", 35)[35], tr_use("T6", 40)[40], tr_use("T6", 45)[45], tr_use("T6", 50)[50], tr_use("T6", 55)[55], tr_use("T6", 60)[60], tr_use("T6", 65)[65], tr_use("T6", 70)[70], tr_use("T6", 75)[75], tr_use("T6", 80)[80], tr_use("T6", 85)[85], tr_use("T6", 90)[90], tr_use("T6", 95)[95], tr_use("T6", 100)[100]
            
            #, tr_use("T7", 5)[5], tr_use("T7", 10)[10], tr_use("T7", 15)[15], tr_use("T7", 20)[20], tr_use("T7", 25)[25], tr_use("T7", 30)[30], tr_use("T7", 35)[35], tr_use("T7", 40)[40], tr_use("T7", 45)[45], tr_use("T7", 50)[50], tr_use("T7", 55)[55], tr_use("T7", 60)[60], tr_use("T7", 65)[65], tr_use("T7", 70)[70], tr_use("T7", 75)[75], tr_use("T7", 80)[80], tr_use("T7", 85)[85], tr_use("T7", 90)[90], tr_use("T7", 95)[95], tr_use("T7", 100)[100]
            
            #, tr_use("T8", 5)[5], tr_use("T8", 10)[10], tr_use("T8", 15)[15], tr_use("T8", 20)[20], tr_use("T8", 25)[25], tr_use("T8", 30)[30], tr_use("T8", 35)[35], tr_use("T8", 40)[40], tr_use("T8", 45)[45], tr_use("T8", 50)[50], tr_use("T8", 55)[55], tr_use("T8", 60)[60], tr_use("T8", 65)[65], tr_use("T8", 70)[70], tr_use("T8", 75)[75], tr_use("T8", 80)[80], tr_use("T8", 85)[85], tr_use("T8", 90)[90], tr_use("T8", 95)[95], tr_use("T8", 100)[100]
            
            #, tr_use("T9", 5)[5], tr_use("T9", 10)[10], tr_use("T9", 15)[15], tr_use("T9", 20)[20], tr_use("T9", 25)[25], tr_use("T9", 30)[30], tr_use("T9", 35)[35], tr_use("T9", 40)[40], tr_use("T9", 45)[45], tr_use("T9", 50)[50], tr_use("T9", 55)[55], tr_use("T9", 60)[60], tr_use("T9", 65)[65], tr_use("T9", 70)[70], tr_use("T9", 75)[75], tr_use("T9", 80)[80], tr_use("T9", 85)[85], tr_use("T9", 90)[90], tr_use("T9", 95)[95], tr_use("T9", 100)[100]
            
            #, tr_use("T10", 5)[5], tr_use("T10", 10)[10], tr_use("T10", 15)[15], tr_use("T10", 20)[20], tr_use("T10", 25)[25], tr_use("T10", 30)[30], tr_use("T10", 35)[35], tr_use("T10", 40)[40], tr_use("T10", 45)[45], tr_use("T10", 50)[50], tr_use("T10", 55)[55], tr_use("T10", 60)[60], tr_use("T10", 65)[65], tr_use("T10", 70)[70], tr_use("T10", 75)[75], tr_use("T10", 80)[80], tr_use("T10", 85)[85], tr_use("T10", 90)[90], tr_use("T10", 95)[95], tr_use("T10", 100)[100]
            
            #, tr_use("T11", 5)[5], tr_use("T11", 10)[10], tr_use("T11", 15)[15], tr_use("T11", 20)[20], tr_use("T11", 25)[25], tr_use("T11", 30)[30], tr_use("T11", 35)[35], tr_use("T11", 40)[40], tr_use("T11", 45)[45], tr_use("T11", 50)[50], tr_use("T11", 55)[55], tr_use("T11", 60)[60], tr_use("T11", 65)[65], tr_use("T11", 70)[70], tr_use("T11", 75)[75], tr_use("T11", 80)[80], tr_use("T11", 85)[85], tr_use("T11", 90)[90], tr_use("T11", 95)[95], tr_use("T11", 100)[100]
            
            #, tr_use("T1", 0)[-200], tr_use("T2", 0)[-200], tr_use("T3", 0)[-200], tr_use("T4", 0)[-200], tr_use("T5", 0)[-200], tr_use("T6", 0)[-200], tr_use("T7", 0)[-200], tr_use("T8", 0)[-200], tr_use("T9", 0)[-200], tr_use("T10", 0)[-200], tr_use("T11", 0)[-200]
          };
end
